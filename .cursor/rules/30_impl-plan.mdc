---
description: 
globs: 
alwaysApply: false
---
---
description: Plan d'implÃ©mentation dÃ©taillÃ© et analyse sÃ©quentielle pilotÃ©e par MCP Supabase
globs: ["Front/agroflow-workspace/**/*", "Back/**/*", "**/*.ts", "**/*.java"]
alwaysApply: false
---

## RÃ´le & Contexte
Ce fichier dÃ©finit la mÃ©thodologie d'analyse sÃ©quentielle et le format du plan d'implÃ©mentation dÃ©taillÃ© pour chaque tÃ¢che, pilotÃ© par MCP Supabase. Il garantit la traÃ§abilitÃ©, la rÃ©flexion et la cohÃ©rence des actions de dÃ©veloppement AgroFlow.

# Plan d'ImplÃ©mentation DÃ©tailÃ© & Analyse SÃ©quentielle PilotÃ©e par MCP Supabase â€“ Projet AgroFlow

## RÃ´le et Contexte
Pour chaque (sous-)tÃ¢che, fournir un plan d'implÃ©mentation dÃ©taillÃ©, traÃ§able et structurÃ©, pilotÃ© par MCP Supabase : analyse, investigation du code, plan d'action, plan de commit/branche, liens vers guidelines. MCP Supabase est la source de vÃ©ritÃ© unique pour toutes les tÃ¢ches de dÃ©veloppement AgroFlow.
- **Lors de la gÃ©nÃ©ration du plan d'implÃ©mentation, l'IA doit systÃ©matiquement lire le champ `guideline_refs` de la tÃ¢che dans la table tasks, relire le contenu des guidelines rÃ©fÃ©rencÃ©es, et analyser la structure du projet avant de proposer le plan d'implÃ©mentation.**

---

## 1. ğŸ§  MÃ©thodologie d'Analyse SÃ©quentielle

### Principe Fondamental
- **PensÃ©e sÃ©quentielle structurÃ©e** pour chaque tÃ¢che : rÃ©flexion initiale, analyse contextuelle, synthÃ¨se progressive, validation conceptuelle.
- **MÃ©moire cumulative** : patterns, anti-patterns, dÃ©cisions architecturales, continuitÃ© analytique.
- **TraÃ§abilitÃ© Supabase** : toute tÃ¢che doit Ãªtre formalisÃ©e et suivie dans MCP Supabase.
- **HiÃ©rarchie explicite** : pour chaque tÃ¢che, l'agent doit utiliser les champs `type` (`epic`, `feature`, `task`) et `parent_task_id` dans la table `tasks` pour reconstituer la hiÃ©rarchie complÃ¨te (epic â†’ feature â†’ task). Pour les sous-tÃ¢ches, utiliser le champ `task_id` pour retrouver la tÃ¢che parente.
- **L'IA doit, pour chaque plan d'implÃ©mentation, lire le champ `guideline_refs` de la tÃ¢che, relire le contenu des guidelines rÃ©fÃ©rencÃ©es, et analyser la structure rÃ©elle du projet (architecture, modules, patterns) avant de proposer le plan d'action.**

### 1.1 VÃ©rification et Activation de MCP Supabase
- Toujours vÃ©rifier que MCP Supabase est actif et le `project_id` connu avant toute analyse.
- Utiliser les commandes `mcp_supabase_list_projects` et `mcp_supabase_execute_sql` pour tester la connexion et rÃ©cupÃ©rer les tÃ¢ches.
- En cas d'erreur ou d'absence de tÃ¢ches, informer l'utilisateur et proposer des solutions (voir instructions dÃ©taillÃ©es dans l'ancienne rÃ¨gle 03).

### 1.2 Processus de PensÃ©e StructurÃ©e
- **RÃ©flexion prÃ©-analyse** : comprendre l'intention profonde, activer la mÃ©moire sÃ©quentielle, identifier patterns/anti-patterns, capitaliser sur l'expÃ©rience.
- **DÃ©composition analytique** : diviser la tÃ¢che en sous-problÃ¨mes, simuler diffÃ©rents scÃ©narios, Ã©valuer alternatives, anticiper consÃ©quences.
- **SynthÃ¨se et validation** : vÃ©rifier la cohÃ©rence globale, valider l'architecture, optimiser conceptuellement.
- **RemontÃ©e hiÃ©rarchique** : pour chaque tÃ¢che, reconstituer la hiÃ©rarchie complÃ¨te (epic, feature, task) en utilisant les champs `type` et `parent_task_id` dans la table `tasks`.

#### Format de rÃ©flexion obligatoire
```markdown
### ğŸ’­ RÃ©flexion Analytique

#### ğŸ§  PensÃ©e Initiale
[RÃ©flexion sur la comprÃ©hension profonde de la tÃ¢che et ses enjeux]

#### ğŸ”— MÃ©moire SÃ©quentielle ActivÃ©e
- **TÃ¢ches similaires** : [RÃ©fÃ©rences aux analyses antÃ©rieures pertinentes]
- **Patterns rÃ©utilisables** : [Solutions/architectures dÃ©jÃ  identifiÃ©es]
- **LeÃ§ons apprises** : [Enseignements des analyses prÃ©cÃ©dentes]

#### ğŸ¯ StratÃ©gie Conceptuelle
[Approche choisie aprÃ¨s rÃ©flexion et justification]

#### âš ï¸ Points d'Attention IdentifiÃ©s
[Risques, dÃ©fis ou aspects critiques dÃ©tectÃ©s pendant la rÃ©flexion]
```

### 1.3 Investigation du Code Existant
- **Backend** : entitÃ©s JPA, repositories, services, controllers, DTOs, mappers, configuration.
- **Frontend** : composants Angular, services, modÃ¨les/interfaces, routing, i18n, UI components.
- **Analyse des dÃ©pendances** : relations, imports, architecture, tÃ¢ches liÃ©es.
- **Outils** : mcp_supabase_execute_sql, codebase_search, file_search, read_file, grep_search.

### 1.4 Questions ClÃ©s Ã  se Poser
- Qu'est-ce qui existe dÃ©jÃ  ? Qu'est-ce qui manque ? Qu'est-ce qui doit Ãªtre modifiÃ© ? Quelles sont les dÃ©pendances ? Y a-t-il des tÃ¢ches liÃ©es dans Supabase ?
- Quelle est la hiÃ©rarchie de cette tÃ¢che ? (retrouver l'epic et la feature parents via `parent_task_id` et `type`)
- Quelles erreurs puis-je Ã©viter grÃ¢ce Ã  l'expÃ©rience ? Quels patterns puis-je rÃ©utiliser ?

---

## 2. ğŸ“‹ Livrable OpÃ©rationnel â€“ Plan d'ImplÃ©mentation DÃ©tailÃ©

### 2.1 Format de rapport dÃ©taillÃ© (Markdown)

```markdown
## ğŸ“‹ Analyse de la TÃ¢che #{TASK_NUMBER} : [Titre de la tÃ¢che]

### ğŸ’­ RÃ©flexion Analytique

#### ğŸ§  PensÃ©e Initiale
[RÃ©flexion sur la comprÃ©hension profonde de la tÃ¢che et ses enjeux]

#### ğŸ”— MÃ©moire SÃ©quentielle ActivÃ©e
- **TÃ¢ches similaires** : [RÃ©fÃ©rences aux analyses antÃ©rieures pertinentes]
- **Patterns rÃ©utilisables** : [Solutions/architectures dÃ©jÃ  identifiÃ©es]
- **LeÃ§ons apprises** : [Enseignements des analyses prÃ©cÃ©dentes]

#### ğŸ¯ StratÃ©gie Conceptuelle
[Approche choisie aprÃ¨s rÃ©flexion et justification]

#### âš ï¸ Points d'Attention IdentifiÃ©s
[Risques, dÃ©fis ou aspects critiques dÃ©tectÃ©s pendant la rÃ©flexion]

### ğŸ·ï¸ HiÃ©rarchie de la TÃ¢che
- **Epic parent** : [Titre, slug, uuid]
- **Feature parente** : [Titre, slug, uuid]
- **TÃ¢che courante** : [Titre, slug, uuid]

### ğŸ“Š Informations de la TÃ¢che
- **NumÃ©ro** : {TASK_NUMBER}
- **Statut** : {Status}
- **PrioritÃ©** : {Priority}
- **AssignÃ© Ã ** : {Assignee}
- **CatÃ©gorie** : {Category}
- **Date d'Ã©chÃ©ance** : {DueDate}

### ğŸ” Ã‰tat Actuel du Code
**Backend :**
- âœ… **Existant** : [Liste des Ã©lÃ©ments dÃ©jÃ  implÃ©mentÃ©s]
- âŒ **Manquant** : [Liste des Ã©lÃ©ments absents]
- âš ï¸ **Ã€ modifier** : [Liste des Ã©lÃ©ments Ã  corriger/amÃ©liorer]

**Frontend :**
- âœ… **Existant** : [Liste des composants/services dÃ©jÃ  implÃ©mentÃ©s]
- âŒ **Manquant** : [Liste des Ã©lÃ©ments absents]
- âš ï¸ **Ã€ modifier** : [Liste des Ã©lÃ©ments Ã  corriger/amÃ©liorer]

### ğŸ“ Plan d'Action DÃ©taillÃ©

#### Phase 1 : Backend
1. **[Action 1]** : [Description prÃ©cise avec fichiers concernÃ©s]
...

#### Phase 2 : Frontend
1. **[Action 1]** : [Description prÃ©cise avec fichiers concernÃ©s]
...

#### Phase 3 : IntÃ©gration et Tests (si applicable)
1. **[Action de test]** : [Description des tests Ã  effectuer]
...

### ğŸ”— DÃ©pendances IdentifiÃ©es
- **PrÃ©requis** : [TÃ¢ches/Ã©lÃ©ments qui doivent Ãªtre terminÃ©s avant]
- **Impact** : [Autres modules/fonctionnalitÃ©s impactÃ©s]
- **TÃ¢ches liÃ©es dans Supabase** : [NumÃ©ros des tÃ¢ches connexes trouvÃ©es]

### â±ï¸ Estimation
- **ComplexitÃ©** : [Faible/Moyenne/Ã‰levÃ©e]
- **Temps estimÃ©** : [Estimation en jours/heures]
- **Risques** : [Points d'attention particuliers]

### ğŸš€ Prochaines Ã‰tapes Supabase
- **Changement de statut proposÃ©** : [Nouveau statut Ã  appliquer]
- **Mise Ã  jour des champs** : [Champs Ã  modifier dans Supabase]
```

### 2.2 Plan de commit/branche et workflow Git

#### ğŸš¦ Workflow obligatoire avant toute nouvelle tÃ¢che
1. **VÃ©rification de la branche courante** : `git branch` ou `git status`
2. **Positionnement sur main** : `git checkout main`
3. **Mise Ã  jour** : `git pull origin main`
4. **CrÃ©ation de la nouvelle branche** : `git checkout -b feature/task/{TASK_NUMBER}-{titre-simplifie}`
5. **VÃ©rification** : Confirmer que le travail commence bien sur la nouvelle branche

#### ğŸ“ Conventions de nommage
- **Format de branche** : `feature/task/{TASK_NUMBER}-{titre-simplifie}`
- **Commit initial** : `"Start task #{TASK_NUMBER}: {titre}"`
- **Exemple** : `feature/task/123-gestion-roles-backend`

#### âš ï¸ RÃ¨gles de sÃ©curitÃ© Git
- **JAMAIS** travailler directement sur la branche `main`
- **TOUJOURS** crÃ©er une nouvelle branche depuis `main` Ã  jour
- **OBLIGATOIRE** : vÃ©rifier la branche active avant de commencer le dÃ©veloppement

### 2.3 Gestion automatique du statut via MCP Supabase

#### ğŸš€ Workflow de dÃ©but de tÃ¢che (OBLIGATOIRE)
1. **VÃ©rification MCP Supabase** : S'assurer que la connexion est active
2. **RÃ©cupÃ©ration des informations** : Lire la tÃ¢che depuis Supabase
3. **VÃ©rification hiÃ©rarchique** : VÃ©rifier et mettre Ã  jour les statuts de la feature et de l'epic parents
4. **Mise Ã  jour du statut** : Passer automatiquement en `in_progress`
5. **TraÃ§abilitÃ©** : Enregistrer l'heure de dÃ©but et l'assignee

**Commandes SQL automatiques (dans l'ordre) :**

1. **RÃ©cupÃ©ration de la hiÃ©rarchie :**
```sql
-- RÃ©cupÃ©rer la tÃ¢che et identifier sa hiÃ©rarchie
SELECT t.id, t.task_number, t.parent_task_id, t.type,
       f.id as feature_id, f.task_number as feature_number, f.status as feature_status,
       e.id as epic_id, e.task_number as epic_number, e.status as epic_status
FROM tasks t
LEFT JOIN tasks f ON (t.type = 'task' AND f.id = t.parent_task_id AND f.type = 'feature')
LEFT JOIN tasks e ON (f.parent_task_id = e.id AND e.type = 'epic')
WHERE t.task_number = {TASK_NUMBER};
```

2. **Mise Ã  jour de l'epic parent (si nÃ©cessaire) :**
```sql
UPDATE tasks 
SET status = 'in_progress', 
    started_at = COALESCE(started_at, NOW())
WHERE id = {EPIC_ID} 
  AND status = 'pending';
```

3. **Mise Ã  jour de la feature parente (si nÃ©cessaire) :**
```sql
UPDATE tasks 
SET status = 'in_progress', 
    started_at = COALESCE(started_at, NOW())
WHERE id = {FEATURE_ID} 
  AND status = 'pending';
```

4. **Mise Ã  jour de la tÃ¢che courante :**
```sql
UPDATE tasks 
SET status = 'in_progress', 
    started_at = NOW(),
    assignee = '59052db0-b51b-43a0-ac89-dafe1ef7d6a7'
WHERE task_number = {TASK_NUMBER};
```

#### âœ… Workflow de fin de tÃ¢che (OBLIGATOIRE)
1. **Validation du travail terminÃ©** : S'assurer que tous les critÃ¨res sont remplis
2. **Mise Ã  jour du statut** : Passer automatiquement en `completed`
3. **VÃ©rification hiÃ©rarchique ascendante** : VÃ©rifier si la feature et l'epic parents peuvent Ãªtre terminÃ©s
4. **TraÃ§abilitÃ©** : Enregistrer l'heure de fin
5. **Commit final** : `"Complete task #{TASK_NUMBER}: {titre}"`

**Commandes SQL automatiques (dans l'ordre) :**

1. **Mise Ã  jour de la tÃ¢che courante :**
```sql
UPDATE tasks 
SET status = 'completed', 
    completed_at = NOW()
WHERE task_number = {TASK_NUMBER};
```

2. **RÃ©cupÃ©ration de la hiÃ©rarchie :**
```sql
-- RÃ©cupÃ©rer la tÃ¢che et identifier sa hiÃ©rarchie
SELECT t.id, t.task_number, t.parent_task_id, t.type,
       f.id as feature_id, f.task_number as feature_number, f.status as feature_status,
       e.id as epic_id, e.task_number as epic_number, e.status as epic_status
FROM tasks t
LEFT JOIN tasks f ON (t.type = 'task' AND f.id = t.parent_task_id AND f.type = 'feature')
LEFT JOIN tasks e ON (f.parent_task_id = e.id AND e.type = 'epic')
WHERE t.task_number = {TASK_NUMBER};
```

3. **VÃ©rification et mise Ã  jour de la feature parente :**
```sql
-- VÃ©rifier si toutes les tÃ¢ches de la feature sont terminÃ©es
UPDATE tasks 
SET status = 'completed', 
    completed_at = NOW()
WHERE id = {FEATURE_ID}
  AND status = 'in_progress'
  AND NOT EXISTS (
    SELECT 1 FROM tasks child_tasks 
    WHERE child_tasks.parent_task_id = {FEATURE_ID} 
      AND child_tasks.type = 'task'
      AND child_tasks.status != 'completed'
  );
```

4. **VÃ©rification et mise Ã  jour de l'epic parent :**
```sql
-- VÃ©rifier si toutes les features de l'epic sont terminÃ©es
UPDATE tasks 
SET status = 'completed', 
    completed_at = NOW()
WHERE id = {EPIC_ID}
  AND status = 'in_progress'
  AND NOT EXISTS (
    SELECT 1 FROM tasks child_features 
    WHERE child_features.parent_task_id = {EPIC_ID} 
      AND child_features.type = 'feature'
      AND child_features.status != 'completed'
  );
```

#### ğŸ“Š Ã‰tats de tÃ¢che reconnus
- **`pending`** : TÃ¢che crÃ©Ã©e, en attente de dÃ©marrage
- **`in_progress`** : TÃ¢che en cours de rÃ©alisation
- **`completed`** : TÃ¢che terminÃ©e avec succÃ¨s
- **`blocked`** : TÃ¢che bloquÃ©e (nÃ©cessite une intervention)
- **`cancelled`** : TÃ¢che annulÃ©e

#### ğŸ” VÃ©rifications obligatoires
- **Avant de commencer** : VÃ©rifier que la tÃ¢che existe et est en statut `pending`
- **Pendant le travail** : La tÃ¢che DOIT Ãªtre en statut `in_progress`
- **Avant de terminer** : VÃ©rifier que tous les critÃ¨res d'acceptation sont remplis
- **TraÃ§abilitÃ©** : Chaque changement de statut DOIT Ãªtre tracÃ© avec horodatage

#### ğŸ”— RÃ¨gles de CohÃ©rence HiÃ©rarchique

##### ğŸ”½ Cascade Descendante (DÃ©but de tÃ¢che)
- **Cascade descendante obligatoire** : Quand une tÃ¢che dÃ©marre, sa feature et son epic parents doivent automatiquement passer en `in_progress` s'ils sont encore en `pending`
- **Logique hiÃ©rarchique** : Epic â†’ Feature â†’ Task - tous les niveaux parents doivent Ãªtre actifs
- **PrÃ©servation des dates** : Utiliser `COALESCE(started_at, NOW())` pour ne pas Ã©craser une date de dÃ©but existante
- **VÃ©rification conditionnelle** : Ne mettre Ã  jour que les Ã©lÃ©ments parents en statut `pending`

##### ğŸ”¼ Cascade Ascendante (Fin de tÃ¢che)
- **Cascade ascendante automatique** : Quand une tÃ¢che se termine, vÃ©rifier si sa feature parente peut Ãªtre terminÃ©e
- **VÃ©rification feature** : Si toutes les tÃ¢ches d'une feature sont `completed`, la feature passe automatiquement en `completed`
- **VÃ©rification epic** : Si toutes les features d'un epic sont `completed`, l'epic passe automatiquement en `completed`
- **Conditions strictes** : Utiliser `NOT EXISTS` pour s'assurer qu'aucune tÃ¢che/feature enfant n'est encore active
- **Mise Ã  jour conditionnelle** : Ne terminer que les Ã©lÃ©ments parents en statut `in_progress`

##### ğŸ“Š SchÃ©ma de Cascade Bidirectionnelle
```
DÃ‰BUT DE TÃ‚CHE (Cascade â¬‡ï¸)          FIN DE TÃ‚CHE (Cascade â¬†ï¸)
================================      ================================

Epic (pending) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º    Epic (in_progress)
  â¬‡ï¸ auto in_progress                    â¬†ï¸ auto completed si toutes 
                                           features terminÃ©es
Feature (pending) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º    Feature (in_progress)  
  â¬‡ï¸ auto in_progress                    â¬†ï¸ auto completed si toutes
                                           tÃ¢ches terminÃ©es
Task (pending â†’ in_progress)           Task (in_progress â†’ completed)

RÃ‰SULTAT : HiÃ©rarchie cohÃ©rente       RÃ‰SULTAT : ComplÃ©tion automatique
```

#### âš ï¸ RÃ¨gles de sÃ©curitÃ© Supabase
- **TOUJOURS** vÃ©rifier la connexion MCP avant toute opÃ©ration
- **JAMAIS** modifier le statut manuellement sans passer par la procÃ©dure
- **OBLIGATOIRE** : utiliser l'UUID utilisateur par dÃ©faut : `59052db0-b51b-43a0-ac89-dafe1ef7d6a7`
- **SYSTÃ‰MATIQUE** : horodater chaque changement de statut
- **HIÃ‰RARCHIQUE** : Toujours vÃ©rifier et mettre Ã  jour la hiÃ©rarchie complÃ¨te (epic/feature/task)

### 2.4 Suivi de progression et logging (RECOMMANDÃ‰)

#### ğŸ“ Points de contrÃ´le rÃ©guliers
Pendant l'exÃ©cution d'une tÃ¢che, il est **fortement recommandÃ©** de noter l'Ã©volution via des commentaires dans Supabase :

**Situations nÃ©cessitant un logging :**
- **Obstacles rencontrÃ©s** : ProblÃ¨mes techniques, blocages, dÃ©pendances manquantes
- **DÃ©cisions techniques** : Choix d'architecture, changements d'approche
- **Ã‰tapes franchies** : Validation de sous-tÃ¢ches, points de contrÃ´le
- **Temps passÃ©** : Estimation vs rÃ©alitÃ©, complexitÃ© inattendue
- **DÃ©couvertes** : Insights techniques, patterns identifiÃ©s

#### ğŸ”„ Commande de logging automatique
```sql
UPDATE tasks 
SET comments = COALESCE(comments, '') || 
    E'\n[' || NOW() || '] ' || '{MESSAGE_DE_PROGRESSION}'
WHERE task_number = {TASK_NUMBER};
```

#### ğŸ“Š Exemples de messages de progression
```
[2024-01-15 14:30] âœ… Backend: EntitÃ© RawMaterial crÃ©Ã©e avec succÃ¨s
[2024-01-15 15:15] âš ï¸ ProblÃ¨me: Conflit avec enum existant, rÃ©solution en cours
[2024-01-15 16:45] ğŸ”„ Frontend: Composant liste terminÃ©, passage au formulaire
[2024-01-15 17:20] ğŸ’¡ DÃ©cision: Utilisation de DataTableComponent au lieu de mat-table
[2024-01-15 18:00] âœ… Tests: Validation des critÃ¨res d'acceptation OK
```

#### ğŸ¯ Jalons de progression recommandÃ©s
1. **25% - Analyse terminÃ©e** : Code existant analysÃ©, plan validÃ©
2. **50% - Backend terminÃ©** : EntitÃ©s, services, controllers implÃ©mentÃ©s
3. **75% - Frontend terminÃ©** : Composants, routing, i18n implÃ©mentÃ©s
4. **100% - IntÃ©gration terminÃ©e** : Tests passÃ©s, critÃ¨res d'acceptation validÃ©s

#### ğŸ” Avantages du logging de progression
- **TraÃ§abilitÃ©** : Historique dÃ©taillÃ© des dÃ©cisions et obstacles
- **Apprentissage** : Capitalisation des insights pour futures tÃ¢ches
- **DÃ©bogage** : Identification rapide des problÃ¨mes rÃ©currents
- **Estimation** : AmÃ©lioration des estimations futures
- **Collaboration** : VisibilitÃ© pour l'Ã©quipe sur l'avancement

#### â° Moments automatiques de mise Ã  jour (OBLIGATOIRE)

**Les commentaires de progression seront mis Ã  jour automatiquement Ã  chaque commit Git :**

1. **Au dÃ©but de la tÃ¢che** (commit initial) :
   ```bash
   git commit -m "Start task #{TASK_NUMBER}: {titre}"
   ```
   ```sql
   UPDATE tasks SET comments = '[' || NOW() || '] ğŸš€ DÃ©but de la tÃ¢che - Branche crÃ©Ã©e et plan validÃ©'
   WHERE task_number = {TASK_NUMBER};
   ```

2. **Ã€ chaque commit significatif** (automatique) :
   Le message de commit sera automatiquement ajoutÃ© aux commentaires de la tÃ¢che :
   ```sql
   UPDATE tasks SET comments = COALESCE(comments, '') || 
       E'\n[' || NOW() || '] ğŸ“ Commit: {MESSAGE_DU_COMMIT}'
   WHERE task_number = {TASK_NUMBER};
   ```

3. **Ã€ la fin de la tÃ¢che** (commit final) :
   ```bash
   git commit -m "Complete task #{TASK_NUMBER}: {titre}"
   ```
   ```sql
   UPDATE tasks SET comments = COALESCE(comments, '') || 
       E'\n[' || NOW() || '] âœ… TÃ¢che terminÃ©e - Tous les critÃ¨res d\'acceptation validÃ©s'
   WHERE task_number = {TASK_NUMBER};
   ```

#### ğŸ”— IntÃ©gration Git + Supabase
**Workflow automatique Ã  chaque commit :**
1. **DÃ©veloppeur/IA fait un commit** â†’ `git commit -m "message"`
2. **Extraction automatique** â†’ RÃ©cupÃ©ration du numÃ©ro de tÃ¢che depuis la branche
3. **Mise Ã  jour Supabase** â†’ Ajout du message de commit aux commentaires
4. **Horodatage** â†’ TraÃ§abilitÃ© complÃ¨te avec timestamps

#### ğŸ“ Format des messages de commit recommandÃ©s
- `feat(#123): add RawMaterial entity and repository`
- `fix(#123): resolve enum conflict in StorageCondition`
- `ui(#123): implement RawMaterial list component`
- `test(#123): validate all acceptance criteria`

#### ğŸ”„ Impact sur les habitudes de commit de l'IA

**Cette rÃ¨gle encourage naturellement l'agent IA Ã  :**

- **Commits plus frÃ©quents** : Chaque commit devient un point de progression tracÃ©
- **Messages plus descriptifs** : Les messages servent de documentation de progression
- **GranularitÃ© fine** : DÃ©coupage du travail en Ã©tapes atomiques et logiques
- **Meilleure traÃ§abilitÃ©** : Historique Git plus dÃ©taillÃ© et exploitable
- **Feedback utilisateur** : VisibilitÃ© en temps rÃ©el de l'avancement

#### ğŸ“¦ StratÃ©gie de commit recommandÃ©e pour l'IA
1. **Commit aprÃ¨s chaque fichier significatif** : EntitÃ©, service, composant
2. **Commit aprÃ¨s chaque phase logique** : Backend complet, frontend complet
3. **Commit aprÃ¨s rÃ©solution de problÃ¨me** : Correction de bug, conflit rÃ©solu
4. **Commit aprÃ¨s validation** : Tests passÃ©s, critÃ¨re d'acceptation validÃ©

#### ğŸ¯ BÃ©nÃ©fices pour l'utilisateur
- **Suivi en temps rÃ©el** : Voir l'IA progresser Ã©tape par Ã©tape
- **Rollback prÃ©cis** : Revenir Ã  un Ã©tat spÃ©cifique facilement
- **ComprÃ©hension du processus** : Voir comment l'IA structure son travail
- **Historique dÃ©taillÃ©** : TraÃ§abilitÃ© complÃ¨te des dÃ©cisions et actions

#### ğŸ“Š FrÃ©quence recommandÃ©e
- **Minimum obligatoire** : DÃ©but, milieu, fin de tÃ¢che
- **Optimal** : Ã€ chaque Ã©tape logique significative (fichier crÃ©Ã©/modifiÃ©)
- **Temps rÃ©el** : DÃ¨s qu'une action concrÃ¨te est terminÃ©e

---

## 3. ğŸ”— RÃ©fÃ©rences
- [10_project-architecture.mdc](mdc:10_project-architecture.mdc)
- [40_guidelines-frontend.mdc](mdc:40_guidelines-frontend.mdc)
- [41_guidelines-backend.mdc](mdc:41_guidelines-backend.mdc)
- [20_task-breakdown.mdc](mdc:20_task-breakdown.mdc)
- [QualitÃ© & Quality Gate](mdc:50_quality-gate.mdc)
