const express = require("express");
const cors = require("cors");
const redis = require("redis");
const path = require("path");

const app = express();
const PORT = process.env.PORT || 3001;

// Configuration du projet
const PROJECT_NAME = process.env.PROJECT_NAME || "MyProject";
const PROJECT_FULL_NAME = `${PROJECT_NAME} Task Manager`;

// Configuration Redis avec variables d'environnement
const REDIS_HOST = process.env.REDIS_HOST || "localhost";
const REDIS_PORT = process.env.REDIS_PORT || 6379;

const redisClient = redis.createClient({
  url: `redis://${REDIS_HOST}:${REDIS_PORT}`,
  socket: {
    reconnectStrategy: (retries) => Math.min(retries * 50, 500),
  },
});

// Middleware
app.use(cors());
app.use(express.json());

// Routes HTML avec injection du PROJECT_NAME (AVANT express.static)
// Route pour injecter la configuration du projet dans les pages HTML
app.get("/", (req, res) => {
  console.log(`üìÑ Route '/' appel√©e - PROJECT_NAME: ${PROJECT_NAME}`);
  const fs = require("fs");
  let html = fs.readFileSync(path.join(__dirname, "index.html"), "utf8");
  
  // Injecter la variable PROJECT_NAME
  console.log(`üîß Remplacement: window.PROJECT_NAME = "${PROJECT_NAME}";`);
  html = html.replace(
    'window.PROJECT_NAME = window.PROJECT_NAME || "MyProject";',
    `window.PROJECT_NAME = "${PROJECT_NAME}";`
  );
  
  // Remplacer le placeholder dans le HTML si pr√©sent
  html = html.replace(/__PROJECT_NAME_H1_PLACEHOLDER__/g, PROJECT_NAME);
  
  res.send(html);
});

app.get("/edit.html", (req, res) => {
  console.log(`üìÑ Route '/edit.html' appel√©e - PROJECT_NAME: ${PROJECT_NAME}`);
  const fs = require("fs");
  let html = fs.readFileSync(path.join(__dirname, "edit.html"), "utf8");
  
  // Injecter la variable PROJECT_NAME
  html = html.replace(
    'window.PROJECT_NAME = window.PROJECT_NAME || "MyProject";',
    `window.PROJECT_NAME = "${PROJECT_NAME}";`
  );
  
  // Remplacer le placeholder dans le HTML si pr√©sent
  html = html.replace(/__PROJECT_NAME_H1_PLACEHOLDER__/g, PROJECT_NAME);
  
  res.send(html);
});

// Route g√©n√©rale pour tous les fichiers HTML avec injection du PROJECT_NAME
app.get("*.html", (req, res) => {
  console.log(`üìÑ Route g√©n√©rale '*.html' appel√©e pour ${req.path} - PROJECT_NAME: ${PROJECT_NAME}`);
  const fs = require("fs");
  const filePath = path.join(__dirname, req.path);
  
  // V√©rifier si le fichier existe
  if (!fs.existsSync(filePath)) {
    return res.status(404).json({ error: "Fichier non trouv√©" });
  }
  
  let html = fs.readFileSync(filePath, "utf8");
  
  // Injecter la variable PROJECT_NAME
  html = html.replace(
    'window.PROJECT_NAME = window.PROJECT_NAME || "MyProject";',
    `window.PROJECT_NAME = "${PROJECT_NAME}";`
  );
  
  // Remplacer tous les placeholders dans le HTML
  html = html.replace(/__PROJECT_NAME_H1_PLACEHOLDER__/g, PROJECT_NAME);
  html = html.replace(/__PROJECT_NAME__/g, PROJECT_NAME);
  html = html.replace(/__PROJECT_FULL_NAME__/g, PROJECT_FULL_NAME);
  
  res.send(html);
});

// Middleware pour les fichiers statiques (APR√àS les routes HTML)
app.use(express.static(path.join(__dirname)));

// Connexion Redis avec gestion d'erreurs
redisClient.on("error", (err) => {
  console.error("Erreur Redis:", err);
});

redisClient.on("connect", () => {
  console.log("‚úÖ Connect√© √† Redis");
});

// Route de sant√©
app.get("/api/health", async (req, res) => {
  try {
    await redisClient.ping();
    res.json({ status: "ok", redis: "connected" });
  } catch (error) {
    res
      .status(500)
      .json({ status: "error", redis: "disconnected", error: error.message });
  }
});

// R√©cup√©rer toutes les t√¢ches
app.get("/api/tasks", async (req, res) => {
  try {
    // R√©cup√©rer toutes les cl√©s de t√¢ches
    const taskKeys = await redisClient.keys("tasks:*");
    const tasks = [];

    for (const key of taskKeys) {
      // Ignorer l'index
      if (key === "tasks:index") continue;

      try {
        const taskData = await redisClient.sendCommand(["JSON.GET", key]);
        if (taskData) {
          tasks.push(JSON.parse(taskData));
        }
      } catch (error) {
        console.error(`Erreur lors de la r√©cup√©ration de ${key}:`, error);
      }
    }

    // Trier par ID
    tasks.sort((a, b) => a.id - b.id);
    res.json(tasks);
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration des t√¢ches:", error);
    res
      .status(500)
      .json({ error: "Erreur lors de la r√©cup√©ration des t√¢ches" });
  }
});

// R√©cup√©rer une t√¢che sp√©cifique
app.get("/api/tasks/:id", async (req, res) => {
  try {
    const taskId = req.params.id;
    const taskData = await redisClient.sendCommand([
      "JSON.GET",
      `tasks:${taskId}`,
    ]);

    if (!taskData) {
      return res.status(404).json({ error: "T√¢che non trouv√©e" });
    }

    res.json(JSON.parse(taskData));
  } catch (error) {
    console.error(
      `Erreur lors de la r√©cup√©ration de la t√¢che ${req.params.id}:`,
      error
    );
    res
      .status(500)
      .json({ error: "Erreur lors de la r√©cup√©ration de la t√¢che" });
  }
});

// R√©cup√©rer l'index des t√¢ches
app.get("/api/tasks/index", async (req, res) => {
  try {
    const indexData = await redisClient.sendCommand([
      "JSON.GET",
      "tasks:index",
    ]);

    if (!indexData) {
      // Cr√©er un index par d√©faut si il n'existe pas
      const defaultIndex = {
        total_tasks: 0,
        status_breakdown: {
          "√Ä faire": 0,
          "En cours": 0,
          Termin√©e: 0,
          "En attente": 0,
          Annul√©e: 0,
        },
        priority_breakdown: {
          Haute: 0,
          Moyenne: 0,
          Basse: 0,
        },
        category_breakdown: {
          Frontend: 0,
          Backend: 0,
          Fullstack: 0,
          Testing: 0,
          OPS: 0,
        },
        last_updated: new Date().toISOString(),
      };
      return res.json(defaultIndex);
    }

    res.json(JSON.parse(indexData));
  } catch (error) {
    console.error("Erreur lors de la r√©cup√©ration de l'index:", error);
    res
      .status(500)
      .json({ error: "Erreur lors de la r√©cup√©ration de l'index" });
  }
});

// Mettre √† jour le statut d'une t√¢che
app.put("/api/tasks/:id/status", async (req, res) => {
  try {
    const taskId = req.params.id;
    const { status } = req.body;

    if (!status) {
      return res.status(400).json({ error: "Le statut est requis" });
    }

    // V√©rifier si la t√¢che existe
    const existingTask = await redisClient.sendCommand([
      "JSON.GET",
      `tasks:${taskId}`,
    ]);
    if (!existingTask) {
      return res.status(404).json({ error: "T√¢che non trouv√©e" });
    }

    // Mettre √† jour le statut
    await redisClient.sendCommand([
      "JSON.SET",
      `tasks:${taskId}`,
      "$.status",
      `"${status}"`,
    ]);

    // Mettre √† jour le timestamp
    const now = new Date().toISOString();
    await redisClient.sendCommand([
      "JSON.SET",
      `tasks:${taskId}`,
      "$.updated_at",
      `"${now}"`,
    ]);

    // Si la t√¢che est termin√©e ou annul√©e, mettre √† jour completed_at
    if (status === "Termin√©e" || status === "Annul√©e") {
      await redisClient.sendCommand([
        "JSON.SET",
        `tasks:${taskId}`,
        "$.completed_at",
        `"${now}"`,
      ]);
    } else {
      await redisClient.sendCommand([
        "JSON.SET",
        `tasks:${taskId}`,
        "$.completed_at",
        "null",
      ]);
    }

    // Recalculer et mettre √† jour l'index
    await updateTasksIndex();

    // R√©cup√©rer la t√¢che mise √† jour
    const updatedTaskData = await redisClient.sendCommand([
      "JSON.GET",
      `tasks:${taskId}`,
    ]);
    res.json(JSON.parse(updatedTaskData));
  } catch (error) {
    console.error(
      `Erreur lors de la mise √† jour de la t√¢che ${req.params.id}:`,
      error
    );
    res
      .status(500)
      .json({ error: "Erreur lors de la mise √† jour de la t√¢che" });
  }
});

// Mettre √† jour une t√¢che compl√®te
app.put("/api/tasks/:id", async (req, res) => {
  try {
    const taskId = req.params.id;
    const {
      title,
      description,
      status,
      priority,
      category,
      assignee,
      dueDate,
      tags,
    } = req.body;

    // V√©rifier si la t√¢che existe
    const existingTaskData = await redisClient.sendCommand([
      "JSON.GET",
      `tasks:${taskId}`,
    ]);
    if (!existingTaskData) {
      return res.status(404).json({ error: "T√¢che non trouv√©e" });
    }

    const existingTask = JSON.parse(existingTaskData);
    const now = new Date().toISOString();

    // Cr√©er l'objet de t√¢che mis √† jour
    const updatedTask = {
      ...existingTask,
      title: title || existingTask.title,
      description: description || existingTask.description,
      status: status || existingTask.status,
      priority: priority || existingTask.priority,
      category: category || existingTask.category,
      assignee: assignee || existingTask.assignee,
      dueDate: dueDate || existingTask.dueDate,
      tags: tags || existingTask.tags,
      updated_at: now,
    };

    // Si le statut change vers "Termin√©e" ou "Annul√©e", mettre √† jour completed_at
    if (
      (status === "Termin√©e" || status === "Annul√©e") &&
      existingTask.status !== status
    ) {
      updatedTask.completed_at = now;
    } else if (status && status !== "Termin√©e" && status !== "Annul√©e") {
      updatedTask.completed_at = null;
    }

    // Sauvegarder la t√¢che mise √† jour
    await redisClient.sendCommand([
      "JSON.SET",
      `tasks:${taskId}`,
      "$",
      JSON.stringify(updatedTask),
    ]);

    // Recalculer et mettre √† jour l'index
    await updateTasksIndex();

    res.json(updatedTask);
  } catch (error) {
    console.error(
      `Erreur lors de la mise √† jour compl√®te de la t√¢che ${req.params.id}:`,
      error
    );
    res
      .status(500)
      .json({ error: "Erreur lors de la mise √† jour de la t√¢che" });
  }
});

// Cr√©er une nouvelle t√¢che
app.post("/api/tasks", async (req, res) => {
  try {
    const {
      title,
      description,
      status,
      priority,
      category,
      assignee,
      dueDate,
      tags,
      tasks,
      problem,
      objective,
    } = req.body;

    // Validation des champs obligatoires
    if (!title) {
      return res.status(400).json({ error: "Le titre est requis" });
    }

    // G√©n√©rer un nouvel ID
    let newId = 1;
    try {
      const allTaskKeys = await redisClient.keys("tasks:*");
      const numericIds = allTaskKeys
        .map(key => {
          const match = key.match(/tasks:(\d+)$/);
          return match ? parseInt(match[1], 10) : 0;
        })
        .filter(id => id > 0);
      
      if (numericIds.length > 0) {
        newId = Math.max(...numericIds) + 1;
      }
    } catch (error) {
      console.error("Erreur lors de la g√©n√©ration de l'ID:", error);
    }

    const now = new Date().toISOString();
    const today = new Date().toISOString().split('T')[0];

    // Cr√©er l'objet de t√¢che
    const newTask = {
      id: newId,
      title: title.trim(),
      description: description?.trim() || "",
      status: status || "√Ä faire",
      priority: priority || "Moyenne",
      category: category || "Fullstack",
      assignee: assignee?.trim() || "",
      dueDate: dueDate || today,
      tags: Array.isArray(tags) ? tags : (tags ? tags.split(',').map(t => t.trim()) : []),
      tasks: Array.isArray(tasks) ? tasks : (tasks ? tasks.split('\n').filter(t => t.trim()) : []),
      problem: problem?.trim() || "",
      objective: objective?.trim() || "",
      source_file: "web-interface.mdc",
      created_at: today,
      updated_at: now,
      completed_at: null,
    };

    // Sauvegarder la nouvelle t√¢che
    await redisClient.sendCommand([
      "JSON.SET",
      `tasks:${newId}`,
      "$",
      JSON.stringify(newTask),
    ]);

    console.log(`Nouvelle t√¢che cr√©√©e avec l'ID ${newId}: ${title}`);

    // Recalculer et mettre √† jour l'index
    await updateTasksIndex();

    res.status(201).json(newTask);
  } catch (error) {
    console.error("Erreur lors de la cr√©ation de la t√¢che:", error);
    res.status(500).json({ error: "Erreur lors de la cr√©ation de la t√¢che" });
  }
});

// Supprimer une t√¢che
app.delete("/api/tasks/:id", async (req, res) => {
  try {
    const taskId = req.params.id;

    // V√©rifier si la t√¢che existe
    const existingTask = await redisClient.sendCommand([
      "JSON.GET",
      `tasks:${taskId}`,
    ]);
    if (!existingTask) {
      return res.status(404).json({ error: "T√¢che non trouv√©e" });
    }

    // Supprimer la t√¢che
    await redisClient.del(`tasks:${taskId}`);

    console.log(`T√¢che supprim√©e avec l'ID ${taskId}`);

    // Recalculer et mettre √† jour l'index
    await updateTasksIndex();

    res.json({ message: "T√¢che supprim√©e avec succ√®s", id: parseInt(taskId) });
  } catch (error) {
    console.error(`Erreur lors de la suppression de la t√¢che ${req.params.id}:`, error);
    res.status(500).json({ error: "Erreur lors de la suppression de la t√¢che" });
  }
});

// Fonction utilitaire pour mettre √† jour l'index des t√¢ches
async function updateTasksIndex() {
  try {
    // R√©cup√©rer toutes les t√¢ches
    const taskKeys = await redisClient.keys("tasks:*");
    const tasks = [];

    for (const key of taskKeys) {
      if (key === "tasks:index") continue;

      try {
        const taskData = await redisClient.sendCommand(["JSON.GET", key]);
        if (taskData) {
          tasks.push(JSON.parse(taskData));
        }
      } catch (error) {
        console.error(
          `Erreur lors de la r√©cup√©ration de ${key} pour l'index:`,
          error
        );
      }
    }

    // Calculer les statistiques
    const index = {
      total_tasks: tasks.length,
      status_breakdown: {
        "√Ä faire": 0,
        "En cours": 0,
        Termin√©e: 0,
        "En attente": 0,
        Annul√©e: 0,
      },
      priority_breakdown: {
        Haute: 0,
        Moyenne: 0,
        Basse: 0,
      },
      category_breakdown: {
        Frontend: 0,
        Backend: 0,
        Fullstack: 0,
        Testing: 0,
        OPS: 0,
      },
      task_ids: tasks.map((t) => t.id).sort((a, b) => a - b),
      last_updated: new Date().toISOString(),
    };

    // Compter les t√¢ches par statut, priorit√© et cat√©gorie
    tasks.forEach((task) => {
      if (index.status_breakdown.hasOwnProperty(task.status)) {
        index.status_breakdown[task.status]++;
      }
      if (index.priority_breakdown.hasOwnProperty(task.priority)) {
        index.priority_breakdown[task.priority]++;
      }
      if (index.category_breakdown.hasOwnProperty(task.category)) {
        index.category_breakdown[task.category]++;
      }
    });

    // Sauvegarder l'index
    await redisClient.sendCommand([
      "JSON.SET",
      "tasks:index",
      "$",
      JSON.stringify(index),
    ]);
    console.log("üìä Index des t√¢ches mis √† jour");
  } catch (error) {
    console.error("Erreur lors de la mise √† jour de l'index:", error);
  }
}

// Gestion des erreurs 404
app.use((req, res) => {
  res.status(404).json({ error: "Route non trouv√©e" });
});

// Initialisation du serveur
async function startServer() {
  try {
    // Se connecter √† Redis
    await redisClient.connect();

    // D√©marrer le serveur Express
    app.listen(PORT, () => {
      console.log(
        `üöÄ ${PROJECT_FULL_NAME} d√©marr√© sur http://localhost:${PORT}`
      );
      console.log(`üìä API disponible sur http://localhost:${PORT}/api`);
      console.log(`üåê Interface web disponible sur http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error(`‚ùå Erreur lors du d√©marrage du serveur ${PROJECT_NAME}:`, error);
    process.exit(1);
  }
}

// Gestion propre de l'arr√™t
process.on("SIGINT", async () => {
  console.log(`\nüõë Arr√™t du serveur ${PROJECT_NAME}...`);
  try {
    await redisClient.quit();
    process.exit(0);
  } catch (error) {
    console.error("Erreur lors de la fermeture:", error);
    process.exit(1);
  }
});

// D√©marrer le serveur
startServer();
